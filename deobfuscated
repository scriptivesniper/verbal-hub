do
    loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/VerbalHubz/Verbal-Hub/refs/heads/main/verbal%20hub%20v2%20orion", true))()
    
    Window = OrionLib:MakeWindow({
        Name = "Verbal Hub v3 Ftap",
        HidePremium = false,
        SaveConfig = true,
        IntroEnabled = true,
        IntroText = "Welcome To Verbal Hub V3 Ftap",
        IntroIcon = "rbxassetid://112374567322808",
        ConfigFolder = "Verbal Config"
    })

    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local GrabEvent = ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("CreateGrabLine")
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer
    local workspace = game:GetService("Workspace")
    
    lagIntensity = 50
    local batchSize = 50
    batchInterval = 0.08
    reExecuteEnabled = false
    local reExecuteInterval = 3
    mainEnabled = false
    local invisibleLagEnabled = false
    local nonLagLagEnabled = false
    local range = 100
    local targetPart = workspace:FindFirstChildOfClass("Part")
    local randomRange = 100
    local loopsPerRequest = 1000
    isLagAllToggled = false
    local targetType = "Workspace"
    local currentPlayerIndex = 1
    speedMultiplier = 1.1
    local WhitelistedPlayers = WhitelistedPlayers or {}
    
    local MainTab = Window:MakeTab({
        Name = "Main",
        Icon = "rbxassetid://4483345998"
    })
    
    local WhitelistTab = Window:MakeTab({
        Name = "Whitelist",
        Icon = "rbxassetid://4483345998"
    })
    
    local selectedPlayers = {}
    local whitelistDropdown = WhitelistTab:AddDropdown({
        Name = "Select Player",
        Options = {},
        Callback = function(player)
            selectedPlayers[player] = true
        end
    })
    
    local whitelistedDropdown = WhitelistTab:AddDropdown({
        Name = "Whitelisted Players",
        Options = {},
        Callback = function(player)
            selectedPlayers[player] = true
        end
    })
    
    local function updateWhitelistDropdown()
        local playerNames = {}
        for playerName in pairs(WhitelistedPlayers) do
            table.insert(playerNames, playerName)
        end
        whitelistedDropdown:Refresh(playerNames, true)
    end
    
    local function updatePlayerDropdown()
        local playerOptions = {}
        for _, player in ipairs(Players:GetPlayers()) do
            if ((player ~= localPlayer) and not WhitelistedPlayers[player.Name]) then
                local displayOption = player.Name .. " (" .. player.DisplayName .. ")"
                table.insert(playerOptions, displayOption)
            end
        end
        whitelistDropdown:Refresh(playerOptions, true)
    end
    
    Players.PlayerAdded:Connect(updatePlayerDropdown)
    Players.PlayerRemoving:Connect(updatePlayerDropdown)
    updatePlayerDropdown()
    updateWhitelistDropdown()
    
    WhitelistTab:AddButton({
        Name = "Add Player",
        Callback = function()
            for playerName in pairs(selectedPlayers) do
                local username = playerName:match("^(.-) %(") or playerName
                WhitelistedPlayers[username] = true
            end
            updateWhitelistDropdown()
            updatePlayerDropdown()
            selectedPlayers = {}
        end
    })
    
    WhitelistTab:AddButton({
        Name = "Remove Player",
        Callback = function()
            for playerName in pairs(selectedPlayers) do
                local username = playerName:match("^(.-) %(") or playerName
                WhitelistedPlayers[username] = nil
            end
            updateWhitelistDropdown()
            updatePlayerDropdown()
            selectedPlayers = {}
        end
    })
    
    local function fireGrabEventsForWorkspace()
        for i = 1, batchSize do
            task.spawn(function()
                local target = workspace:FindFirstChildOfClass("Part")
                if target then
                    local randomPos = Vector3.new(math.random(-range, range), math.random(-range, range), math.random(-range, range))
                    GrabEvent:FireServer(target, CFrame.new(randomPos))
                end
            end)
        end
    end
    
    local function fireNonLagLagEvents()
        if (targetType == "Workspace") then
            for i = 1, batchSize do
                task.spawn(function()
                    local target = workspace:FindFirstChildOfClass("Part")
                    if target then
                        local randomPos = Vector3.new(math.random(-range, range), math.random(-range, range), math.random(-range, range))
                        GrabEvent:FireServer(target, CFrame.new(randomPos))
                    end
                end)
            end
        end
    end
    
    local function fireGrabEventsForOtherTargets()
        if (targetType == "AllPlayersHead") then
            for _, player in ipairs(Players:GetPlayers()) do
                if ((player ~= localPlayer) and player.Character and player.Character:FindFirstChild("Head")) then
                    task.spawn(function()
                        local target = player.Character:FindFirstChild("Head")
                        if target then
                            local currentInterval = batchInterval
                            while mainEnabled do
                                GrabEvent:FireServer(target, CFrame.new(target.Position))
                                wait(currentInterval)
                                currentInterval = math.max(0.1, currentInterval / speedMultiplier)
                            end
                        end
                    end)
                end
            end
        elseif (targetType == "WhitelistedPlayersHead") then
            local playerList = {}
            for playerName in pairs(WhitelistedPlayers) do
                local player = Players:FindFirstChild(playerName)
                if player then
                    table.insert(playerList, player)
                end
            end
            if (#playerList > 0) then
                currentPlayerIndex = (currentPlayerIndex % #playerList) + 1
                local player = playerList[currentPlayerIndex]
                task.spawn(function()
                    local target = player.Character and player.Character:FindFirstChild("Head")
                    if target then
                        local currentInterval = batchInterval
                        while mainEnabled do
                            GrabEvent:FireServer(target, CFrame.new(0.1125335693359375, -0.15124130249023438, -0.5) * CFrame.Angles(3.031834602355957, -1.3067572116851807, -3.1407527923583984))
                            wait(currentInterval)
                            currentInterval = math.max(0.1, currentInterval / speedMultiplier)
                        end
                    end
                end)
            end
        end
    end
    
    local function fireInvisibleLagEvent()
        local targetPart = _G.targetPart
        local randomRange = _G.randomRange
        local loopsPerRequest = _G.loopsPerRequest
        if (targetPart and randomRange and loopsPerRequest) then
            local randomPositions = {}
            for _ = 1, loopsPerRequest do
                local randomPosition = CFrame.new(math.random(-randomRange, randomRange), math.random(-randomRange, randomRange), math.random(-randomRange, randomRange))
                table.insert(randomPositions, randomPosition)
            end
            if GrabEvent then
                GrabEvent:FireServer(targetPart, randomPositions)
            else
                warn("GrabEvent is not defined!")
            end
        else
            warn("targetPart, randomRange, or loopsPerRequest is not defined!")
        end
    end
    
    local function reExecuteLoop()
        while reExecuteEnabled do
            task.wait(reExecuteInterval)
            if mainEnabled then
                if (targetType == "Workspace") then
                    fireGrabEventsForWorkspace()
                else
                    fireGrabEventsForOtherTargets()
                end
            end
        end
    end
    
    local function createLagWithGrabLine()
        for _, object in ipairs(workspace:GetDescendants()) do
            if (object:IsA("BasePart") and (object.Parent ~= localPlayer.Character)) then
                local cf = object.CFrame * CFrame.new(math.random(-lagIntensity, lagIntensity), math.random(-lagIntensity, lagIntensity), math.random(-lagIntensity, lagIntensity)) * CFrame.Angles(math.rad(math.random(0, 360)), math.rad(math.random(0, 360)), math.rad(math.random(0, 360)))
                GrabEvent:FireServer(object, cf)
            end
        end
    end
    
    local function toggleLagAll()
        if isLagAllToggled then
            spawn(function()
                local currentInterval = reExecuteInterval
                while isLagAllToggled do
                    createLagWithGrabLine()
                    task.wait(currentInterval)
                    currentInterval = math.max(0.1, currentInterval / speedMultiplier)
                end
            end)
        end
    end
    
    MainTab:AddDropdown({
        Name = "Target",
        Default = "Workspace",
        Options = {"Workspace", "AllPlayersHead", "WhitelistedPlayersHead"},
        Callback = function(selected)
            targetType = selected
            if (selected == "Workspace") then
                speedMultiplier = 1.1
            end
        end
    })
    
    MainTab:AddSlider({
        Name = "Lag Intensity",
        Min = 1,
        Max = 100,
        Default = 1,
        Color = Color3.fromRGB(255, 0, 0),
        Increment = 1,
        Callback = function(value)
            lagIntensity = value
            batchSize = value * 5
            batchInterval = 0.1 / value
        end
    })
    
    MainTab:AddToggle({
        Name = "Enable Lag",
        Default = false,
        Callback = function(value)
            mainEnabled = value
            if value then
                while mainEnabled do
                    if (targetType == "Workspace") then
                        fireGrabEventsForWorkspace()
                    else
                        fireGrabEventsForOtherTargets()
                    end
                    wait(1)
                end
            end
        end
    })
    
    MainTab:AddToggle({
        Name = "Invisible Lag All",
        Default = false,
        Callback = function(value)
            invisibleLagEnabled = value
            if value then
                while invisibleLagEnabled do
                    fireInvisibleLagEvent()
                    task.wait()
                end
            end
        end
    })
    
    MainTab:AddToggle({
        Name = "Non-Lag Lag All",
        Default = false,
        Callback = function(value)
            nonLagLagEnabled = value
            if value then
                while nonLagLagEnabled do
                    fireNonLagLagEvents()
                    task.wait()
                end
            end
        end
    })
    
    MainTab:AddToggle({
        Name = "Lag All (perm)",
        Default = false,
        Callback = function(value)
            isLagAllToggled = value
            toggleLagAll()
        end
    })
    
    MainTab:AddSlider({
        Name = "Workspace Lag Intensity",
        Min = 1,
        Max = 2000,
        Default = 50,
        Increment = 10,
        Callback = function(value)
            lagIntensity = value
        end
    })
    
    MainTab:AddSlider({
        Name = "Re-Execute Interval (s)",
        Min = 0.1,
        Max = 1,
        Default = 0.4,
        Color = Color3.fromRGB(255, 0, 0),
        Increment = 0.05,
        Callback = function(value)
            reExecuteInterval = value
        end
    })
    
    MainTab:AddToggle({
        Name = "Re-Execute Lag",
        Default = false,
        Callback = function(value)
            reExecuteEnabled = value
            if value then
                task.spawn(reExecuteLoop)
            end
        end
    })
    
    MainTab:AddSlider({
        Name = "Speed Multiplier",
        Min = 1.1,
        Max = 2,
        Default = 1.1,
        Color = Color3.fromRGB(0, 0, 255),
        Increment = 0.1,
        Callback = function(value)
            speedMultiplier = value
        end
    })
    
    MainTab:AddToggle({
        Name = "Anti Lag",
        Default = false,
        Callback = function(Value)
            local grabEvents = ReplicatedStorage:FindFirstChild("GrabEvents")
            if not grabEvents then
                warn("GrabEvents folder not found!")
                return
            end
            if Value then
                grabEvents:FindFirstChild("CreateGrabLine"):Destroy()
            elseif not grabEvents:FindFirstChild("CreateGrabLine") then
                Instance.new("RemoteEvent", grabEvents).Name = "CreateGrabLine"
            end
        end
    })
    
    local WarningTab = Window:MakeTab({
        Name = "Warnings",
        Icon = "rbxassetid://4483345998",
        PremiumOnly = false
    })
    
    WarningTab:AddParagraph("Warning Section", "In the options hub, there is a section labeled '(place shurkin if u dont wanna get kicked 20% of getting kicked you should hide).' This section serves as a warning for users to strategically use a specific item, known as 'shurkin,' to avoid the risk of being kicked from the game. Players are advised that there is a 20% chance of being kicked and should consider hiding to increase their chances of staying in the game.")
    
    GrabWhitelist = Window:MakeTab({
        Name = " Auras",
        Icon = "rbxassetid://4483345998",
        PremiumOnly = false
    })
    
    _G.WhitelistedPlayers = _G.WhitelistedPlayers or {}
    
    local function updateWhitelist(enabled)
        if enabled then
            for _, friend in ipairs(game.Players.LocalPlayer:GetFriendsOnline()) do
                if not table.find(_G.WhitelistedPlayers, friend.UserId) then
                    table.insert(_G.WhitelistedPlayers, friend.UserId)
                end
            end
        else
            for _, friend in ipairs(game.Players.LocalPlayer:GetFriendsOnline()) do
                local index = table.find(_G.WhitelistedPlayers, friend.UserId)
                if index then
                    table.remove(_G.WhitelistedPlayers, index)
                end
            end
        end
    end
    
    WhitelistTab:AddToggle({
        Name = "Whitelist Friends",
        Default = false,
        Callback = function(enabled)
            _G.WhitelistFriends = enabled
            updateWhitelist(enabled)
        end
    })
    
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local TornadoParts = {}
    local flungPlayers = {}
    local TornadoSettings = {
        Enabled = false,
        Layers = 3,
        Speed = 50,
        Height = 10,
        MaxDistance = 40,
        FlingVelocity = 999,
        RotationSpeed = 50,
        RadiusMultiplier = 10,
        PlayerSeparation = 5,
        GrabInterval = 0.5,
        MinDistance = 5,
        ApproachSpeed = 20
    }
    local lastGrabTime = 0
    
    _G.WhitelistedPlayers = _G.WhitelistedPlayers or {}
    
    local function setNoclip(character, state)
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = not state
            end
        end
    end
    
    local function setNetworkOwner(part)
        pcall(function()
            game:GetService("ReplicatedStorage").GrabEvents.SetNetworkOwner:FireServer(part, part.CFrame)
        end)
    end
    
    local function createBodyMovers(part, targetPosition, rotation, approach)
        local existingMover = TornadoParts[part]
        if not existingMover then
            local bodyVelocity = Instance.new("BodyVelocity", part)
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            local bodyGyro = Instance.new("BodyGyro", part)
            bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            TornadoParts[part] = {Velocity = bodyVelocity, Gyro = bodyGyro}
        else
            if approach then
                existingMover.Velocity.Velocity = (targetPosition - part.Position).Unit * TornadoSettings.ApproachSpeed
            else
                existingMover.Velocity.Velocity = (targetPosition - part.Position).Unit * TornadoSettings.Speed
            end
            existingMover.Gyro.CFrame = rotation
        end
    end
    
    local function flingPlayer(part)
        if TornadoParts[part] then
            TornadoParts[part].Velocity:Destroy()
            TornadoParts[part].Gyro:Destroy()
            TornadoParts[part] = nil
        end
        local bodyVelocity = Instance.new("BodyVelocity", part)
        bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bodyVelocity.Velocity = Vector3.new(math.random(-TornadoSettings.FlingVelocity, TornadoSettings.FlingVelocity), TornadoSettings.FlingVelocity, math.random(-TornadoSettings.FlingVelocity, TornadoSettings.FlingVelocity))
        game:GetService("Debris"):AddItem(bodyVelocity, 1)
    end
    
    local function tornadoEffect()
        local localCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local localRoot = localCharacter:WaitForChild("HumanoidRootPart")
        local playerPos = localRoot.Position
        local players = Players:GetPlayers()
        local validPlayers = {}
        
        for _, player in ipairs(players) do
            if ((player ~= LocalPlayer) and player.Character and not _G.WhitelistedPlayers[player.Name]) then
                local otherRoot = player.Character:FindFirstChild("HumanoidRootPart")
                if (otherRoot and ((otherRoot.Position - playerPos).Magnitude <= TornadoSettings.MaxDistance)) then
                    table.insert(validPlayers, player)
                    setNoclip(player.Character, true)
                end
            end
        end
        
        local angleOffset = 360 / #validPlayers
        for i, player in ipairs(validPlayers) do
            local otherRoot = player.Character:FindFirstChild("HumanoidRootPart")
            if not flungPlayers[player] then
                setNetworkOwner(otherRoot)
                local distanceToPlayer = (otherRoot.Position - playerPos).Magnitude
                local separationAngle = (i - 1) * angleOffset
                local separationRadius = TornadoSettings.PlayerSeparation * (i - 1)
                local baseX = playerPos.X + (separationRadius * math.cos(math.rad(separationAngle)))
                local baseZ = playerPos.Z + (separationRadius * math.sin(math.rad(separationAngle)))
                local approach = distanceToPlayer > TornadoSettings.MinDistance
                
                for j = 1, TornadoSettings.Layers do
                    local angle = (tick() * TornadoSettings.RotationSpeed) + separationAngle + (j * (360 / TornadoSettings.Layers))
                    local radius = (j * TornadoSettings.RadiusMultiplier) + separationRadius
                    local posX, posZ
                    
                    if approach then
                        local direction = (playerPos - otherRoot.Position).Unit
                        local offset = direction * TornadoSettings.MinDistance
                        posX = playerPos.X - offset.X
                        posZ = playerPos.Z - offset.Z
                    else
                        posX = baseX + (radius * math.cos(math.rad(angle)))
                        posZ = baseZ + (radius * math.sin(math.rad(angle)))
                    end
                    
                    local posY = playerPos.Y + ((j * TornadoSettings.Height) / TornadoSettings.Layers)
                    local targetPosition = Vector3.new(posX, posY, posZ)
                    local rotation = CFrame.Angles(0, math.rad(angle), 0)
                    createBodyMovers(otherRoot, targetPosition, rotation, approach)
                end
            end
        end
    end
    
    local function clearBodyMovers()
        if ((tick() - lastGrabTime) >= TornadoSettings.GrabInterval) then
            for part, _ in pairs(TornadoParts) do
                if not flungPlayers[Players:GetPlayerFromCharacter(part.Parent)] then
                    flingPlayer(part)
                    flungPlayers[Players:GetPlayerFromCharacter(part.Parent)] = true
                end
            end
            TornadoParts = {}
            lastGrabTime = tick()
        end
    end
    
    RunService.Heartbeat:Connect(function()
        if TornadoSettings.Enabled then
            tornadoEffect()
        else
            clearBodyMovers()
            flungPlayers = {}
        end
    end)
    
    GrabWhitelist:AddToggle({
        Name = "Enable Tornado",
        Default = false,
        Callback = function(value)
            TornadoSettings.Enabled = value
            if not value then
                clearBodyMovers()
                flungPlayers = {}
            end
        end
    })
    
    GrabWhitelist:AddSlider({
        Name = "Tornado Layers",
        Min = 1,
        Max = 10,
        Default = 3,
        Callback = function(value)
            TornadoSettings.Layers = value
        end
    })
    
    GrabWhitelist:AddSlider({
        Name = "Tornado Speed",
        Min = 1,
        Max = 100,
        Default = 50,
        Callback = function(value)
            TornadoSettings.Speed = value
        end
    })
    
    GrabWhitelist:AddSlider({
        Name = "Tornado Height",
        Min = 1,
        Max = 50,
        Default = 10,
        Callback = function(value)
            TornadoSettings.Height = value
        end
    })
    
    GrabWhitelist:AddSlider({
        Name = "Max Distance",
        Min = 10,
        Max = 100,
        Default = 40,
        Callback = function(value)
            TornadoSettings.MaxDistance = value
        end
    })
    
    GrabWhitelist:AddSlider({
        Name = "Rotation Speed",
        Min = 1,
        Max = 100,
        Default = 50,
        Callback = function(value)
            TornadoSettings.RotationSpeed = value
        end
    })
    
    GrabWhitelist:AddSlider({
        Name = "Min Distance to Player",
        Min = 1,
        Max = 20,
        Default = 5,
        Callback = function(value)
            TornadoSettings.MinDistance = value
        end
    })
    
    GrabWhitelist:AddSlider({
        Name = "Approach Speed",
        Min = 1,
        Max = 50,
        Default = 20,
        Callback = function(value)
            TornadoSettings.ApproachSpeed = value
        end
    })
    
    local Players = game:GetService("Players")
    local Debris = game:GetService("Debris")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local SetNetworkOwner = ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("SetNetworkOwner")
    local DestroyGrabLine = ReplicatedStorage:WaitForChild("GrabEvents"):WaitForChild("DestroyGrabLine")
    local UserInputService = game:GetService("UserInputService")
    local TweenService = game:GetService("TweenService")
    local RunService = game:GetService("RunService")
    local localPlayer = Players.LocalPlayer
    local auraCoroutine = nil
    local controlledPlayers = {}
    local isAuraEnabled = false
    local auraRadius = 40
    local flingUpwardForce = 200
    local anchorDuration = 1
    local flingDelay = 0.5
    
    local function positionPlayersInTrain(humanoidRootPart)
        local currentOffset = Vector3.new(0, 0, -5)
        for _, player in ipairs(controlledPlayers) do
            if (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then
                local playerTorso = player.Character.HumanoidRootPart
                SetNetworkOwner:FireServer(playerTorso, player.Character.HumanoidRootPart.CFrame)
                local targetCFrame = humanoidRootPart.CFrame * CFrame.new(currentOffset)
                local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
                local tween = TweenService:Create(playerTorso, tweenInfo, {CFrame = targetCFrame})
                tween:Play()
                currentOffset = currentOffset + Vector3.new(0, 0, -5)
            end
        end
    end
    
    local blobalter = 1
    local blobmanCoroutine = nil
    local blobman = nil
    local isBlobmanControlEnabled = false
    local grabInterval = 3
    
    local function isDescendantOf(child, parent)
        while child ~= nil do
            if (child == parent) then
                return true
            end
            child = child.Parent
        end
        return false
    end
    
    local function blobGrabPlayer(player, blobman)
        if (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then
            local humanoidRootPart = player.Character.HumanoidRootPart
            local detectorName = ((blobalter == 1) and "LeftDetector") or "RightDetector"
            local detector = blobman:FindFirstChild(detectorName)
            if detector then
                local line = Instance.new("Part")
                line.Size = Vector3.new(0.1, 0.1, (blobman.PrimaryPart.Position - humanoidRootPart.Position).Magnitude)
                line.CFrame = CFrame.new(blobman.PrimaryPart.Position, humanoidRootPart.Position) * CFrame.new(0, 0, -line.Size.Z / 2)
                line.Anchored = true
                line.CanCollide = false
                line.Transparency = 0.5
                line.BrickColor = BrickColor.new("Neon cyan")
                line.Material = Enum.Material.Neon
                line.Parent = workspace
                
                local hitbox = Instance.new("Part")
                hitbox.Size = Vector3.new(1, 2, 1)
                hitbox.CFrame = humanoidRootPart.CFrame
                hitbox.Anchored = true
                hitbox.CanCollide = false
                hitbox.Transparency = 0.8
                hitbox.BrickColor = BrickColor.new("Neon green")
                hitbox.Material = Enum.Material.Neon
                hitbox.Parent = workspace
                
                local args = {
                    [1] = detector,
                    [2] = humanoidRootPart,
                    [3] = detector:FindFirstChild(detectorName .. "Weld")
                }
                blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
                blobalter = 3 - blobalter
                wait(0.1)
                line:Destroy()
                hitbox:Destroy()
            else
                warn("Detector not found:", detectorName)
            end
        end
    end
    
    local function movePlayerUpward(player)
        if (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then
            local humanoidRootPart = player.Character.HumanoidRootPart
            local upwardForce = 50
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
            bodyVelocity.Velocity = Vector3.new(0, upwardForce, 0)
            bodyVelocity.Parent = humanoidRootPart
            game:GetService("Debris"):AddItem(bodyVelocity, 0.3)
        end
    end
    
    local combinedToggle = Window:MakeTab({
        Name = "Combined Control",
        Icon = "rbxassetid://18719810809",
        PremiumOnly = false
    })
    
    local invisToggle = combinedToggle:AddToggle({
        Name = "Invisible Toggle (Aura + Blobman TryHard Mode)",
        Default = false,
        Save = true,
        Callback = function(enabled)
            isAuraEnabled = enabled
            isBlobmanControlEnabled = enabled
            if enabled then
                auraCoroutine = coroutine.create(function()
                    while isAuraEnabled do
                        local success, err = pcall(function()
                            local character = localPlayer.Character
                            if (character and character:FindFirstChild("Head") and character:FindFirstChild("HumanoidRootPart")) then
                                local head = character.Head
                                local humanoidRootPart = character.HumanoidRootPart
                                controlledPlayers = {}
                                
                                for _, player in pairs(Players:GetPlayers()) do
                                    coroutine.wrap(function()
                                        if ((player ~= localPlayer) and player.Character) then
                                            local playerCharacter = player.Character
                                            local playerTorso = playerCharacter:FindFirstChild("Torso") or playerCharacter:FindFirstChild("HumanoidRootPart")
                                            if playerTorso then
                                                local distance = (playerTorso.Position - humanoidRootPart.Position).Magnitude
                                                if (distance <= auraRadius) then
                                                    table.insert(controlledPlayers, player)
                                                    playerTorso.Anchored = true
                                                    SetNetworkOwner:FireServer(playerTorso, playerCharacter.HumanoidRootPart.CFrame)
                                                    task.wait(flingDelay)
                                                    
                                                    if (playerTorso and playerTorso.Parent) then
                                                        local flingUpwardVelocity = Instance.new("BodyVelocity", playerTorso)
                                                        flingUpwardVelocity.Name = "FlingUpward"
                                                        flingUpwardVelocity.Velocity = Vector3.new(0, flingUpwardForce, 0)
                                                        flingUpwardVelocity.MaxForce = Vector3.new(0, math.huge, 0)
                                                        Debris:AddItem(flingUpwardVelocity, 0.5)
                                                    end
                                                    
                                                    task.delay(anchorDuration, function()
                                                        if (playerTorso and playerTorso.Parent) then
                                                            playerTorso.Anchored = false
                                                            DestroyGrabLine:FireServer(playerTorso)
                                                        end
                                                    end)
                                                end
                                            end
                                        end
                                    end)()
                                end
                            end
                        end)
                        
                        if not success then
                            warn("Error in Aura: " .. tostring(err))
                        end
                        wait(0.02)
                    end
                end)
                coroutine.resume(auraCoroutine)
                
                blobmanCoroutine = coroutine.create(function()
                    local foundBlobman = false
                    for i, v in pairs(workspace:GetDescendants()) do
                        if (v.Name == "CreatureBlobman") then
                            if (v:FindFirstChild("VehicleSeat") and v.VehicleSeat:FindFirstChild("SeatWeld") and isDescendantOf(v.VehicleSeat.SeatWeld.Part1, localPlayer.Character)) then
                                blobman = v
                                foundBlobman = true
                                break
                            end
                        end
                    end
                    
                    if not foundBlobman then
                        OrionLib:MakeNotification({
                            Name = "Error",
                            Content = "You must be mounted upon a blobman to begin this process. Please mount one and toggle this again!",
                            Image = "rbxassetid://4483345998",
                            Time = 5
                        })
                        invisToggle:Set(false)
                        blobman = nil
                        coroutine.close(blobmanCoroutine)
                        blobmanCoroutine = nil
                        return
                    end
                    
                    while isBlobmanControlEnabled do
                        if (blobman and blobman:FindFirstChild("BlackHoleKick")) then
                            local spawnLocation = workspace:FindFirstChild("SpawnLocation") or workspace:FindFirstDescendant("SpawnLocation")
                            if spawnLocation then
                                local blackHoleKick = blobman:FindFirstChild("BlackHoleKick")
                                local circle = Instance.new("Part", workspace)
                                circle.Shape = "Cylinder"
                                circle.Size = Vector3.new(1, 0.1, 1)
                                circle.CFrame = spawnLocation.CFrame * CFrame.Angles(math.rad(90), 0, 0)
                                circle.Anchored = true
                                circle.CanCollide = false
                                circle.Transparency = 0.5
                                circle.BrickColor = BrickColor.new("White")
                                circle.Material = Enum.Material.Neon
                                circle.Name = "BlackHoleKickVisual"
                                
                                local tween = TweenService:Create(circle, TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {
                                    Size = Vector3.new(8, 0.1, 8),
                                    Transparency = 1
                                })
                                tween:Play()
                                wait(1)
                                circle:Destroy()
                            end
                        end
                        
                        for i, v in pairs(Players:GetChildren()) do
                            if (blobman and (v ~= localPlayer)) then
                                blobGrabPlayer(v, blobman)
                            end
                        end
                        wait(grabInterval)
                        
                        for i, v in pairs(Players:GetChildren()) do
                            if (v ~= localPlayer) then
                                movePlayerUpward(v)
                            end
                        end
                    end
                end)
                coroutine.resume(blobmanCoroutine)
            else
                if auraCoroutine then
                    coroutine.close(auraCoroutine)
                    auraCoroutine = nil
                end
                controlledPlayers = {}
                
                if blobmanCoroutine then
                    coroutine.close(blobmanCoroutine)
                    blobmanCoroutine = nil
                    blobman = nil
                end
            end
        end
    })
    
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local Workspace = game:GetService("Workspace")
    local localPlayer = Players.LocalPlayer
    local blobalter = 1
    local neonLineColor = Color3.fromRGB(50, 255, 0)
    local hitboxOutlineColor = Color3.fromRGB(0, 0, 0)
    local blobmanCoroutine
    local scriptObjects = {}
    local fullScriptEnabled = false
    
    local function addScriptObject(object)
        table.insert(scriptObjects, object)
    end
    
    local function cleanupScriptObjects()
        for _, obj in pairs(scriptObjects) do
            if (obj and obj.Parent) then
                obj:Destroy()
            end
        end
        scriptObjects = {}
    end
    
    local function createHitbox(position)
        local hitbox = Instance.new("Part")
        hitbox.Size = Vector3.new(2, 2, 2)
        hitbox.Position = position
        hitbox.Anchored = true
        hitbox.Transparency = 1
        hitbox.CanCollide = false
        hitbox.Parent = Workspace
        addScriptObject(hitbox)
        
        local outline = Instance.new("Highlight")
        outline.OutlineColor = hitboxOutlineColor
        outline.OutlineTransparency = 0
        outline.Parent = hitbox
        addScriptObject(outline)
        
        task.delay(0.1, function()
            if hitbox then
                hitbox:Destroy()
            end
        end)
    end
    
    local function createNeonLine(part1, part2)
        if not fullScriptEnabled then
            return
        end
        
        local attachment0 = Instance.new("Attachment", part1)
        local attachment1 = Instance.new("Attachment", part2)
        local beam = Instance.new("Beam")
        beam.Attachment0 = attachment0
        beam.Attachment1 = attachment1
        beam.Color = ColorSequence.new(neonLineColor)
        beam.Width0 = 0.1
        beam.Width1 = 0.1
        beam.FaceCamera = true
        beam.Parent = part1
        
        addScriptObject(beam)
        addScriptObject(attachment0)
        addScriptObject(attachment1)
        
        task.delay(0.1, function()
            if beam then
                beam:Destroy()
            end
            if attachment0 then
                attachment0:Destroy()
            end
            if attachment1 then
                attachment1:Destroy()
            end
        end)
    end
    
    local function blobGrabPlayer(player, blobman)
        if not fullScriptEnabled then
            return
        end
        
        if (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then
            local humanoidRootPart = player.Character.HumanoidRootPart
            if (blobalter == 1) then
                local detector = blobman:FindFirstChild("LeftDetector")
                if detector then
                    local args = {
                        [1] = detector,
                        [2] = humanoidRootPart,
                        [3] = detector:FindFirstChild("LeftWeld")
                    }
                    blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
                    blobalter = 2
                end
            else
                local detector = blobman:FindFirstChild("RightDetector")
                if detector then
                    local args = {
                        [1] = detector,
                        [2] = humanoidRootPart,
                        [3] = detector:FindFirstChild("RightWeld")
                    }
                    blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
                    blobalter = 1
                end
            end
            createHitbox(humanoidRootPart.Position)
            createNeonLine(detector, humanoidRootPart)
        end
    end
    
    local function startBlobmanControl()
        blobmanCoroutine = coroutine.create(function()
            local blobman
            for _, v in pairs(Workspace:GetDescendants()) do
                if ((v.Name == "CreatureBlobman") and v:FindFirstChild("VehicleSeat") and v.VehicleSeat:FindFirstChild("SeatWeld")) then
                    if (v.VehicleSeat.SeatWeld.Part1 == localPlayer.Character.HumanoidRootPart) then
                        blobman = v
                        break
                    end
                end
            end
            
            if not blobman then
                warn("No mounted blobman found")
                return
            end
            
            while fullScriptEnabled do
                for _, player in pairs(Players:GetPlayers()) do
                    blobGrabPlayer(player, blobman)
                end
                task.wait()
            end
        end)
        coroutine.resume(blobmanCoroutine)
    end
    
    combinedToggle:AddToggle({
        Name = "Blobman Kick All (Insane Mode)",
        Default = false,
        Callback = function(enabled)
            fullScriptEnabled = enabled
            if enabled then
                startBlobmanControl()
            else
                if blobmanCoroutine then
                    coroutine.close(blobmanCoroutine)
                    blobmanCoroutine = nil
                end
                cleanupScriptObjects()
            end
        end
    })
    
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local Workspace = game:GetService("Workspace")
    local RunService = game:GetService("RunService")
    local localPlayer = Players.LocalPlayer
    local floatHeight = 20
    local flingHeight = 10
    local flingVelocity = 1.25
    local scriptObjects = {}
    local fullScriptEnabled = false
    local tossLoop = false
    local blobman = nil
    local detectingPlayers = false
    local attachedPlayers = {}
    local blobalter = 1
    local grabDelay = 0.001
    local dropDelay = 0.001
    local loopDelay = 0.005
    local spinSpeed = 5
    local grabDropSpeed = 1
    
    local function addScriptObject(object)
        table.insert(scriptObjects, object)
    end
    
    local function cleanupScriptObjects()
        for _, obj in pairs(scriptObjects) do
            if (obj and obj.Parent) then
                obj:Destroy()
            end
        end
        scriptObjects = {}
    end
    
    local function createBrightWhiteCircle(position)
        local part = Instance.new("Part")
        part.Shape = "Cylinder"
        part.Material = "Neon"
        part.Color = Color3.new(1, 1, 1)
        part.Size = Vector3.new(5, 0.1, 5)
        part.Anchored = true
        part.CanCollide = false
        part.CFrame = CFrame.new(position)
        part.Parent = Workspace
        addScriptObject(part)
        
        local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
        local tween = TweenService:Create(part, tweenInfo, {
            Size = Vector3.new(20, 0.1, 20),
            Transparency = 1
        })
        tween:Play()
        tween.Completed:Connect(function()
            part:Destroy()
        end)
    end
    
    local function flingPlayer(player)
        if (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then
            local humanoidRootPart = player.Character.HumanoidRootPart
            humanoidRootPart:ApplyImpulse(Vector3.new(0, flingVelocity * 500, 0))
            createBrightWhiteCircle(humanoidRootPart.Position)
            task.delay(0.1, function()
                if (humanoidRootPart and humanoidRootPart.Parent) then
                    humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position) + Vector3.new(0, flingHeight, 0)
                end
            end)
        end
    end
    
    local function attachPlayer(player)
        if not fullScriptEnabled then
            return
        end
        
        if (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then
            local humanoidRootPart = player.Character.HumanoidRootPart
            local detectorPartName = ((blobalter == 1) and "LeftDetector") or "RightDetector"
            local detector = blobman:FindFirstChild(detectorPartName)
            
            if detector then
                local weldName = ((blobalter == 1) and "LeftWeld") or "RightWeld"
                local args = {
                    [1] = detector,
                    [2] = humanoidRootPart,
                    [3] = detector:FindFirstChild(weldName)
                }
                blobman:FindFirstChild("BlobmanSeatAndOwnerScript"):FindFirstChild("CreatureGrab"):FireServer(unpack(args))
                table.insert(attachedPlayers, player)
                blobalter = 3 - blobalter
                
                coroutine.wrap(function()
                    local spinAngle = 0
                    while table.find(attachedPlayers, player) and fullScriptEnabled do
                        spinAngle = spinAngle + spinSpeed
                        local offset = Vector3.new(0, floatHeight + (math.sin(time() * 5) * 5, 0)
                        local spinCFrame = CFrame.Angles(0, math.rad(spinAngle), 0)
                        humanoidRootPart.CFrame = (detector.CFrame * spinCFrame) + offset
                        RunService.Heartbeat:Wait()
                    end
                end)()
            end
        end
    end
    
    local function detachPlayers()
        if not fullScriptEnabled then
            return
        end
        
        for i = #attachedPlayers, 1, -1 do
            local player = attachedPlayers[i]
            if (player and player.Character) then
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    local args = {[1] = humanoidRootPart}
                    blobman:FindFirstChild("BlobmanSeatAndOwnerScript"):FindFirstChild("RemoveV3Ver"):FireServer(unpack(args))
                    flingPlayer(player)
                end
            end
            table.remove(attachedPlayers, i)
        end
    end
    
    local function detectAndAttachPlayers()
        if (not blobman or not fullScriptEnabled) then
            return
        end
        
        for _, player in ipairs(Players:GetPlayers()) do
            if ((player ~= localPlayer) and player.Character) then
                local targetHrp = player.Character:FindFirstChild("HumanoidRootPart")
                if (targetHrp and not table.find(attachedPlayers, player)) then
                    attachPlayer(player)
                end
            end
        end
    end
    
    local function startBlobmanControl()
        coroutine.wrap(function()
            blobman = nil
            while not blobman do
                for _, v in ipairs(Workspace:GetDescendants()) do
                    if ((v.Name == "CreatureBlobman") and v:FindFirstChild("VehicleSeat") and v.VehicleSeat:FindFirstChild("SeatWeld")) then
                        if (v.VehicleSeat.SeatWeld.Part1 == localPlayer.Character.HumanoidRootPart) then
                            blobman = v
                            break
                        end
                    end
                end
                
                if not blobman then
                    RunService.Heartbeat:Wait()
                end
            end
            
            if not blobman then
                warn("No mounted blobman found")
                return
            end
            
            detectingPlayers = true
            while fullScriptEnabled and detectingPlayers do
                detectAndAttachPlayers()
                RunService.Heartbeat:Wait()
            end
        end)()
    end
    
    local function onPlayerAdded(player)
        if fullScriptEnabled then
            player.CharacterAdded:Connect(function(character)
                if (player == localPlayer) then
                    detectingPlayers = false
                    attachedPlayers = {}
                    cleanupScriptObjects()
                    startBlobmanControl()
                elseif (blobman and fullScriptEnabled) then
                    RunService.Heartbeat:Wait()
                    attachPlayer(player)
                end
            end)
        end
    end
    
    Players.PlayerAdded:Connect(onPlayerAdded)
    
    local function handleExistingPlayers()
        for _, player in ipairs(Players:GetPlayers()) do
            onPlayerAdded(player)
        end
    end
    
    local function grabAndDropLoop()
        while fullScriptEnabled do
            detectAndAttachPlayers()
            wait(dropDelay * (1 / grabDropSpeed))
            if (#attachedPlayers > 0) then
                detachPlayers()
            end
            wait(grabDelay * (1 / grabDropSpeed))
        end
    end
    
    local function tossLoopFunction()
        while tossLoop do
            if (fullScriptEnabled and (#attachedPlayers > 0)) then
                detachPlayers()
            end
            wait(loopDelay * (1 / grabDropSpeed))
        end
    end
    
    if not combinedToggle then
        warn("combinedToggle is not defined. Creating a placeholder.")
        combinedToggle = {
            AddToggle = function(self, options)
                print("Toggle added:", options.Name, "Default:", options.Default)
                local enabled = options.Default
                options.Callback(enabled)
            end
        }
    end
    
    if not combinedSlider then
        warn("combinedSlider is not defined. Creating a placeholder.")
        combinedSlider = {
            AddSlider = function(self, options)
                print("Slider added:", options.Name, "Default:", options.Default)
                grabDropSpeed = options.Default
                if options.Callback then
                    options.Callback(grabDropSpeed)
                end
            end
        }
    end
    
    combinedToggle:AddToggle({
        Name = "Blobman Grab All (God Mode)",
        Default = false,
        Callback = function(enabled)
            fullScriptEnabled = enabled
            if enabled then
                handleExistingPlayers()
                startBlobmanControl()
                coroutine.wrap(grabAndDropLoop)()
            else
                detectingPlayers = false
                cleanupScriptObjects()
                attachedPlayers = {}
            end
        end
    })
    
    combinedToggle:AddToggle({
        Name = "Drop and Fling Loop",
        Default = false,
        Callback = function(enabled)
            tossLoop = enabled
            if enabled then
                coroutine.wrap(tossLoopFunction)()
            else
            end
        end
    })
    
    combinedSlider:AddSlider({
        Name = "Grab/Drop Speed",
        Min = 0.001,
        Max = 5,
        Default = 1,
        Callback = function(value)
            grabDropSpeed = value
        end
    })
    
    local currentGrabSide = 1
    local auraEffectInterval = 1
    local neonLineColor = Color3.fromRGB(0, 255, 255)
    local brightWhiteColor = Color3.fromRGB(255, 255, 255)
    local blobmanCoroutine
    local activePlayerImages = {}
    
    local function createNeonLine(startPart, endPart)
        local attachmentStart = Instance.new("Attachment", startPart)
        local attachmentEnd = Instance.new("Attachment", endPart)
        local beam = Instance.new("Beam")
        beam.Attachment0 = attachmentStart
        beam.Attachment1 = attachmentEnd
        beam.Color = ColorSequence.new(neonLineColor)
        beam.Width0 = 0.1
        beam.Width1 = 0.1
        beam.FaceCamera = true
        beam.Parent = startPart
        
        task.delay(auraEffectInterval, function()
            if beam then
                beam:Destroy()
            end
            if attachmentStart then
                attachmentStart:Destroy()
            end
            if attachmentEnd then
                attachmentEnd:Destroy()
            end
        end)
    end
    
    local function createBrightWhiteCircle(position)
        local part = Instance.new("Part")
        part.Shape = Enum.PartType.Ball
        part.Size = Vector3.new(5, 5, 5)
        part.Color = brightWhiteColor
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Position = position
        part.Parent = workspace
        
        local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
        local tween = game:GetService("TweenService"):Create(part, tweenInfo, {
            Size = Vector3.new(10, 10, 10),
            Transparency = 1
        })
        tween:Play()
        tween.Completed:Connect(function()
            part:Destroy()
        end)
    end
    
    local function createHitbox(position)
        local hitbox = Instance.new("Part")
        hitbox.Size = Vector3.new(3, 3, 3)
        hitbox.Position = position
        hitbox.Anchored = true
        hitbox.Transparency = 0.5
        hitbox.Color = neonLineColor
        hitbox.CanCollide = false
        hitbox.Material = Enum.Material.Neon
        hitbox.Parent = workspace
        
        task.delay(auraEffectInterval, function()
            if hitbox then
                hitbox:Destroy()
            end
        end)
    end
    
    local function attachImageToPlayer(player)
        if activePlayerImages[player] then
            return
        end
        
        local billboard = Instance.new("BillboardGui")
        billboard.Size = UDim2.new(3, 0, 3, 0)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = player.Character:WaitForChild("HumanoidRootPart")
        
        local imageLabel = Instance.new("ImageLabel")
        imageLabel.Size = UDim2.new(1, 0, 1, 0)
        imageLabel.BackgroundTransparency = 1
        imageLabel.Image = "rbxassetid://14818480125"
        imageLabel.Parent = billboard
        
        activePlayerImages[player] = billboard
    end
    
    local function removeImageFromPlayer(player)
        if activePlayerImages[player] then
            activePlayerImages[player]:Destroy()
            activePlayerImages[player] = nil
        end
    end
    
    local function isDescendant(child, parent)
        while child do
            if (child == parent) then
                return true
            end
            child = child.Parent
        end
        return false
    end
    
    local function grabPlayerWithBlobman(player, blobman)
        if (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then
            local humanoidRootPart = player.Character.HumanoidRootPart
            local detectorName = ((currentGrabSide == 1) and "LeftDetector") or "RightDetector"
            local detector = blobman:FindFirstChild(detectorName)
            
            if detector then
                local args = {detector, humanoidRootPart, detector:FindFirstChild(detectorName .. "Weld")}
                blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
                createNeonLine(detector, humanoidRootPart)
                createBrightWhiteCircle(humanoidRootPart.Position)
                createHitbox(humanoidRootPart.Position)
                attachImageToPlayer(player)
                currentGrabSide = 3 - currentGrabSide
            else
                warn("Detector not found:", detectorName)
            end
        end
    end
    
    local function startBlobmanControl()
        blobmanCoroutine = coroutine.create(function()
            local blobman
            for _, obj in pairs(workspace:GetDescendants()) do
                if ((obj.Name == "CreatureBlobman") and obj:FindFirstChild("VehicleSeat") and obj.VehicleSeat:FindFirstChild("SeatWeld")) then
                    if isDescendant(obj.VehicleSeat.SeatWeld.Part1, localPlayer.Character) then
                        blobman = obj
                        break
                    end
                end
            end
            
            if not blobman then
                warn("No mounted Blobman found")
                return
            end
            
            while true do
                for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                    if (player ~= localPlayer) then
                        grabPlayerWithBlobman(player, blobman)
                    end
                end
                task.wait(auraEffectInterval)
            end
        end)
        coroutine.resume(blobmanCoroutine)
    end
    
    combinedToggle:AddToggle({
        Name = "Blobman Kick All (Normal Mode)",
        Default = false,
        Callback = function(enabled)
            if enabled then
                startBlobmanControl()
            else
                if blobmanCoroutine then
                    coroutine.close(blobmanCoroutine)
                    blobmanCoroutine = nil
                end
                
                for player in pairs(activePlayerImages) do
                    removeImageFromPlayer(player)
                end
            end
        end
    })
    
    _G.AuraConfig = {
        isMoving = false,
        selectedEffect = "None",
        orbitSpeed = 5,
        updateInterval = 0.1,
        ringRadius = 10,
        ballRadius = 8,
        ringHeight = 5,
        ballHeight = 7,
        ringCount = 3,
        ringSpacing = 2,
        distance = 10,
        ringDistance = 10,
        ballDistance = 8
    }
    
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local RunService = game:GetService("RunService")
    local player = Players.LocalPlayer
    local activeToys = {}
    local effectConnection
    local lastUpdateTime = 0
    
    local function createBodyMovers(part, position, rotation)
        local bodyPosition = part:FindFirstChild("BodyPosition") or Instance.new("BodyPosition", part)
        bodyPosition.P = 2000
        bodyPosition.D = 400
        bodyPosition.MaxForce = Vector3.new(5000000, 5000000, 5000000)
        bodyPosition.Position = position
        
        local bodyGyro = part:FindFirstChild("BodyGyro") or Instance.new("BodyGyro", part)
        bodyGyro.P = 2000
        bodyGyro.D = 400
        bodyGyro.MaxTorque = Vector3.new(5000000, 5000000, 5000000)
        bodyGyro.CFrame = rotation
        part.Anchored = false
    end
    
    local function disableCollision(model)
        for _, part in pairs(model:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
    
    local function enableCollision(model)
        for _, part in pairs(model:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    local function addToysToAura()
        for _, toy in ipairs(Workspace:GetDescendants()) do
            if (toy:IsA("Model") and toy:FindFirstChild("SoundPart") and not activeToys[toy]) then
                activeToys[toy] = {
                    angleOffset = math.random(0, 360),
                    ringIndex = math.random(1, _G.AuraConfig.ringCount)
                }
                disableCollision(toy)
            end
        end
    end
    
    local function clearEffects()
        for toy, _ in pairs(activeToys) do
            local soundPart = toy:FindFirstChild("SoundPart")
            if soundPart then
                for _, child in ipairs(soundPart:GetChildren()) do
                    if (child:IsA("BodyMover") or child:IsA("BodyGyro")) then
                        child:Destroy()
                    end
                end
                enableCollision(toy)
            end
        end
        activeToys = {}
    end
    
    local function ringEffect()
        local character = player.Character
        if not character then
            return
        end
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then
            return
        end
        
        for toy, data in pairs(activeToys) do
            local soundPart = toy:FindFirstChild("SoundPart")
            if soundPart then
                data.angleOffset = (data.angleOffset + (_G.AuraConfig.orbitSpeed * _G.AuraConfig.updateInterval)) % 360
                local angle = math.rad(data.angleOffset)
                local posX = rootPart.Position.X + (_G.AuraConfig.ringDistance * math.cos(angle))
                local posZ = rootPart.Position.Z + (_G.AuraConfig.ringDistance * math.sin(angle))
                local posY = rootPart.Position.Y + _G.AuraConfig.ringHeight
                createBodyMovers(soundPart, Vector3.new(posX, posY, posZ), CFrame.Angles(0, angle, 0))
            end
        end
    end
    
    local function ballEffect()
        local character = player.Character
        if not character then
            return
        end
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then
            return
        end
        
        for toy, data in pairs(activeToys) do
            local soundPart = toy:FindFirstChild("SoundPart")
            if soundPart then
                data.angleOffset = (data.angleOffset + (_G.AuraConfig.orbitSpeed * _G.AuraConfig.updateInterval)) % 360
                local angle = math.rad(data.angleOffset)
                local posX = rootPart.Position.X + (_G.AuraConfig.ballDistance * math.sin(angle))
                local posZ = rootPart.Position.Z + (_G.AuraConfig.ballDistance * math.cos(angle))
                local posY = rootPart.Position.Y + _G.AuraConfig.ballHeight
                createBodyMovers(soundPart, Vector3.new(posX, posY, posZ), CFrame.Angles(0, angle, 0))
            end
        end
    end
    
    local function saturnEffect()
        local character = player.Character
        if not character then
            return
        end
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then
            return
        end
        
        for toy, data in pairs(activeToys) do
            local soundPart = toy:FindFirstChild("SoundPart")
            if soundPart then
                data.angleOffset = (data.angleOffset + (_G.AuraConfig.orbitSpeed * _G.AuraConfig.updateInterval)) % 360
                local angle = math.rad(data.angleOffset)
                
                if ((data.ringIndex % 2) == 1) then
                    local posX = rootPart.Position.X + (_G.AuraConfig.ringDistance * math.cos(angle))
                    local posZ = rootPart.Position.Z + (_G.AuraConfig.ringDistance * math.sin(angle))
                    local posY = rootPart.Position.Y + _G.AuraConfig.ringHeight
                    createBodyMovers(soundPart, Vector3.new(posX, posY, posZ), CFrame.Angles(0, angle, 0))
                else
                    local posX = rootPart.Position.X + (_G.AuraConfig.ballDistance * math.sin(angle))
                    local posZ = rootPart.Position.Z + (_G.AuraConfig.ballDistance * math.cos(angle))
                    local posY = rootPart.Position.Y + _G.AuraConfig.ballHeight
                    createBodyMovers(soundPart, Vector3.new(posX, posY, posZ), CFrame.Angles(0, angle, 0))
                end
            end
        end
    end
    
    local function combinedEffect()
        if (_G.AuraConfig.selectedEffect == "Rings") then
            ringEffect()
        elseif (_G.AuraConfig.selectedEffect == "Ball") then
            ballEffect()
        elseif (_G.AuraConfig.selectedEffect == "Saturn") then
            saturnEffect()
        end
    end
    
    local function toggleEffect()
        if _G.AuraConfig.isMoving then
            addToysToAura()
            if effectConnection then
                effectConnection:Disconnect()
            end
            effectConnection = RunService.Heartbeat:Connect(function()
                if ((os.clock() - lastUpdateTime) >= _G.AuraConfig.updateInterval) then
                    lastUpdateTime = os.clock()
                    combinedEffect()
                end
            end)
        else
            if effectConnection then
                effectConnection:Disconnect()
            end
            clearEffects()
        end
    end
    
    local Tab = Window:MakeTab({
        Name = "Aura Effects",
        Icon = "rbxassetid://4483345998",
        PremiumOnly = false
    })
    
    Tab:AddDropdown({
        Name = "Select Aura Effect",
        Default = "None",
        Options = {"None", "Rings", "Ball", "Saturn"},
        Callback = function(value)
            _G.AuraConfig.selectedEffect = value
        end
    })
    
    Tab:AddToggle({
        Name = "Enable/Disable Aura",
        Default = false,
        Callback = function(state)
            _G.AuraConfig.isMoving = state
            toggleEffect()
        end
    })
    
    Tab:AddSlider({
        Name = "Ring Height",
        Min = 1,
        Max = 20,
        Default = 5,
        Callback = function(value)
            _G.AuraConfig.ringHeight = value
        end
    })
    
    Tab:AddSlider({
        Name = "Ball Height",
        Min = 1,
        Max = 20,
        Default = 7,
        Callback = function(value)
            _G.AuraConfig.ballHeight = value
        end
    })
    
    Tab:AddSlider({
        Name = "Ring Distance",
        Min = 5,
        Max = 30,
        Default = 10,
        Callback = function(value)
            _G.AuraConfig.ringDistance = value
        end
    })
    
    Tab:AddSlider({
        Name = "Ball Distance",
        Min = 5,
        Max = 30,
        Default = 8,
        Callback = function(value)
            _G.AuraConfig.ballDistance = value
        end
    })
    
    Tab:AddSlider({
        Name = "Effect Speed",
        Min = 10,
        Max = 1000,
        Default = 10,
        Rounding = 0,
        Callback = function(value)
            _G.AuraConfig.orbitSpeed = value
        end
    })
    
    local GrabWhitelist = Window:MakeTab({
        Name = "Main",
        Icon = "rbxassetid://",
        PremiumOnly = false
    })
    
    _G.WhitelistedPlayers = _G.WhitelistedPlayers or {}
    PermanentWhitelist = {
        s3i5t = true,
        JESSETC92BACKUP23 = true,
        JESSETC92111 = true,
        hahshsin = true,
        Blizz_T = true,
        SaviorLiberty = true,
        Lokick07 = true,
        ggerrtasalt = true,
        ["76rgoyf"] = true,
        Sofiatheprincesa123 = true
    }
    
    function IsInWhitelist(playerName)
        return PermanentWhitelist[playerName] or _G.WhitelistedPlayers[playerName]
    end
    
    local Players = game:GetService("Players")
    local Debris = game:GetService("Debris")
    local SetNetworkOwner = game:GetService("ReplicatedStorage").GrabEvents.SetNetworkOwner
    local localPlayer = Players.LocalPlayer
    local auraRadius = 20
    local spinSpeed = 50
    
    local function applyGrabEffect(playerTorso, angularVelocityVal, bodyVelocityVal)
        for _, effect in pairs(playerTorso:GetChildren()) do
            if (effect:IsA("BodyAngularVelocity") or effect:IsA("BodyVelocity")) then
                effect:Destroy()
            end
        end
        
        if angularVelocityVal then
            local angularVelocity = Instance.new("BodyAngularVelocity", playerTorso)
            angularVelocity.Name = "AngularVel"
            angularVelocity.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            angularVelocity.AngularVelocity = angularVelocityVal
            Debris:AddItem(angularVelocity, 5)
        end
        
        if bodyVelocityVal then
            local bodyVelocity = Instance.new("BodyVelocity", playerTorso)
            bodyVelocity.Name = "BodyVel"
            bodyVelocity.Velocity = bodyVelocityVal
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            Debris:AddItem(bodyVelocity, 5)
        end
    end
    
    GrabWhitelist:AddSlider({
        Name = "Spin Speed",
        Min = 0,
        Max = 100,
        Default = 50,
        Color = Color3.fromRGB(240, 0, 0),
        Increment = 1,
        Save = true,
        Callback = function(value)
            spinSpeed = value * 2
        end
    })
    
    local shakeCoroutine = nil
    local confuseCoroutine = nil
    local yoinkCoroutine = nil
    local shockwaveCoroutine = nil
    local controlCoroutine = nil
    
    GrabWhitelist:AddToggle({
        Name = "Shake Aura",
        Default = false,
        Save = true,
        Callback = function(enabled)
            if enabled then
                shakeCoroutine = coroutine.create(function()
                    while true do
                        local character = localPlayer.Character
                        if (character and character:FindFirstChild("HumanoidRootPart")) then
                            local humanoidRootPart = character.HumanoidRootPart
                            for _, player in pairs(Players:GetPlayers()) do
                                if ((player ~= localPlayer) and not IsInWhitelist(player.Name) and player.Character) then
                                    local playerCharacter = player.Character
                                    local playerTorso = playerCharacter:FindFirstChild("HumanoidRootPart")
                                    if (playerTorso and ((playerTorso.Position - humanoidRootPart.Position).Magnitude <= auraRadius)) then
                                        SetNetworkOwner:FireServer(playerTorso, playerCharacter.HumanoidRootPart.CFrame)
                                        applyGrabEffect(playerTorso, Vector3.new(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), Vector3.new(0, 0, 0))
                                    end
                                end
                            end
                        end
                        wait(0.1)
                    end
                end)
                coroutine.resume(shakeCoroutine)
            elseif shakeCoroutine then
                coroutine.close(shakeCoroutine)
                shakeCoroutine = nil
            end
        end
    })
    
    GrabWhitelist:AddToggle({
        Name = "Confuse Aura",
        Default = false,
        Save = true,
        Callback = function(enabled)
            if enabled then
                confuseCoroutine = coroutine.create(function()
                    while true do
                        local character = localPlayer.Character
                        if (character and character:FindFirstChild("HumanoidRootPart")) then
                            local humanoidRootPart = character.HumanoidRootPart
                            for _, player in pairs(Players:GetPlayers()) do
                                if ((player ~= localPlayer) and not IsInWhitelist(player.Name) and player.Character) then
                                    local playerCharacter = player.Character
                                    local playerTorso = playerCharacter:FindFirstChild("HumanoidRootPart")
                                    if (playerTorso and ((playerTorso.Position - humanoidRootPart.Position).Magnitude <= auraRadius)) then
                                        SetNetworkOwner:FireServer(playerTorso, playerCharacter.HumanoidRootPart.CFrame)
                                        applyGrabEffect(playerTorso, Vector3.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)), Vector3.new(0, 0, 0))
                                    end
                                end
                            end
                        end
                        wait(0.1)
                    end
                end)
                coroutine.resume(confuseCoroutine)
            elseif confuseCoroutine then
                coroutine.close(confuseCoroutine)
                confuseCoroutine = nil
            end
        end
    })
    
    GrabWhitelist:AddToggle({
        Name = "Yoink Aura",
        Default = false,
        Save = true,
        Callback = function(enabled)
            if enabled then
                yoinkCoroutine = coroutine.create(function()
                    while true do
                        local character = localPlayer.Character
                        if (character and character:FindFirstChild("HumanoidRootPart")) then
                            local humanoidRootPart = character.HumanoidRootPart
                            for _, player in pairs(Players:GetPlayers()) do
                                if ((player ~= localPlayer) and not IsInWhitelist(player.Name) and player.Character) then
                                    local playerCharacter = player.Character
OrionLib:Init()
